线程被定义为程序的执行路径。每个路径都定义了一个独特的控制流。
* 生命周期
开始：SyStem.Threading.Thread类对象创建.
结束：线程被终止或完成执行
* 未启动状态：被创建，但Start方法没有调用
* 就绪状态： 准备运行并等待CPU周期
* 不可运行
                1.调用Sleep方法   2.调用Wait方法     3.I/O操作阻塞
*  死亡： 线程完成执行或中止
* 线程创建
  ``` javascript
Thread th =Thread.CurrenThread;
th.Nmae="MyThread";   //线程名字
th.Start();
```
* 管理线程

``` javascript
		static void Main(string[] args)
        {
            ThreadStart childref = new ThreadStart(CallToChildThread);
            Console.WriteLine("In Main: Creating the Child thread");
            Thread childThread = new Thread(childref);
            childThread.Start();
            Console.ReadKey();
        }
        public static void CallToChildThread()
        {
            Console.WriteLine("Child thread starts");
            // 线程暂停 5000 毫秒
            int sleepfor = 5000;
            Console.WriteLine("Child Thread Paused for {0} seconds",
                              sleepfor / 1000);
            Thread.Sleep(sleepfor);
            Console.WriteLine("Child thread resumes");
        }
```

  
* 销毁线程   
    Abort() 方法用于销毁线程
  

``` javascript
      static void Main(string[] args)
        {
            ThreadStart childref = new ThreadStart(CallToChildThread);
            Console.WriteLine("In Main: Creating the Child thread");
            Thread childThread = new Thread(childref);
            childThread.Start();
            // 停止主线程一段时间
            Thread.Sleep(2000);
            // 现在中止子线程
            Console.WriteLine("In Main: Aborting the Child thread");
            childThread.Abort();
            Console.ReadKey();
        }
     	public static void CallToChildThread()
        {
            try
            {
                Console.WriteLine("Child thread starts");
                // 计数到 10
                for (int counter = 0; counter <= 10; counter++)
                {
                    Thread.Sleep(500);
                    Console.WriteLine(counter);
                }
                Console.WriteLine("Child Thread Completed");
            }
            catch (ThreadAbortException e)
            {
                Console.WriteLine("Thread Abort Exception");
            }
            finally
            {
                Console.WriteLine("Couldn't catch the Thread Exception");
            }
        }
```

* 判断多个线程是否都结束的两种方法
               方法一：线程计数器
               方法二：使用Thread.join方法
                   join方法只有在线程结束时才继续执行下面的语句。 可以对每一个线程调用它的join方法，
                 注意，这个调用要在另一个线程里，而不要在主线程，否则程序会被阻塞的。
             

``` javascript
    static void Main(string[] args)  
{    
      Thread thread1 = new Thread(threadMethod);  
      Thread thread2 = new Thread(threadMethod);  
      Thread thread3 = new Thread(threadMethod);  
      thread1.Start(3000);  
      thread2.Start(5000);  
      thread3.Start(7000);  
      Thread joinThread = new Thread(joinAllThread);  
      joinThread.Start(new Thread[] { thread1, thread2, thread3 });  
  
}  
		private static void threadMethod(Object obj)  
{  
    Thread.Sleep(Int32.Parse(obj.ToString()));  
    Console.WriteLine(obj + "毫秒任务结束");  
}  
		private static void joinAllThread(object obj)  
{  
     Thread[] threads = obj as Thread[];  
     foreach (Thread t in threads)  
         t.Join();  
     Console.WriteLine("所有的线程结束");  
}  
```

* 前台和后台线程
        使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止。主线程就是一个前台线程。而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。
``` javascript
 public static void myStaticThreadMethod()  
 {  
     Thread.Sleep(3000);  
 }  
 Thread thread = new Thread(myStaticThreadMethod);  
// thread.IsBackground = true;  
    thread.Start();               
//程序会等待3秒后退出，如果将注释去掉，将thread设成后台线程，则程序会立即退出。
```
