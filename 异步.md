*   "异步方法"：用async关键字修饰 1.异步方法的返回值一般是Task,T是真正的返回值类型，Task。 惯例：异步方法名字以Async结尾。 2.即使方法没有返回值，也最好吧返回值声明为非泛型的Task 3.调用泛型方法时，一般在方法钱加上await，这样拿到的返回值就是泛型制定的T类型\
    4.异步方法的“传染性”：一个方法中如果有await调用，则这个方法也必修修饰为async

```javascript
	static async Task Main(string[] args) {
        string fileName = @"d:/1.txt";
        File.Delete(fileName);
        await File.WriteAllTextAsync(fileName, "hello");
        string s =await File.ReadAllTextAsync(fileName);
      }
```

*   异步方法：

    ```javascript
      static async Task DonloadHtmlAsync(string url,string filename) {
                  HttpClient httpClient = new HttpClient();
                  string html=await httpClient.GetStringAsync(url);
                   await File.WriteAllTextAsync(filename,html);
                  }
    ```

    如果有同样的功能，既有同步方法，又有异步方法，那么首先使用异步方法。 对于不支持的异步方法怎么办？Wait() (无返回值)   ；Result（有返回值） 。风险：死锁。 尽量不用。

*   异步委托

    ```javascript
       ThreadPool.QueueUserWorkItem(async (obj) =>
             {
                 while (true)
                 {
                     Console.WriteLine("XXX");
                 }
             });
    ```

*

    ```javascript
       Thread.CurrentThread.ManagedThreadId //获取当前线程ID
    ```

    await调用的等待期间，.Net会吧当前的线程返回给线程池，等异步方法调用执行完毕后，框架会从线程池再取出来一个线程执行后续的代码。 到要等待的时候，如果发现已经执行结束了，那就没有必要在切换线程，剩下的代码就继续在之前的线程上继续执行。

*   没有async的异步方法 async方法缺点： 1.异步方法会生成一个类，运行效率没有普通方法高 2.可能会占用非常多的线程；

    ```javascript
        static  Task<string> ReadAsync(int number) {
             if (number == 1)
             {
                 return  File.ReadAllTextAsync(@"e:\temp\1.txt");
             
             }
             else if (number == 2)
             {
                 return File.ReadAllTextAsync(@"e:\temp\2.txt");
                
             }
             else {
                 throw new ArgumentException();
             }
         }
    ```

如果一个异步方法只是对别的异步方法调用的转发，并没有太多复杂的逻辑（比如等待A的结果，再调用B；把A调用的返回值拿到内部做一些处理再返回），那么就可以去掉Async关键字。

*   不要用Sleep（） 如果想在异步方法中暂停一段时间，不要用Thread.Sleep（)，因为它会阻塞调用线程，而要用await Task.Delay()。举例：下载一个网址，3秒后下载另一个。

    ```javascript
         HttpClient httpClient  =new HttpClient();
               string s1= await httpClient.GetStringAsync("http://www.youzack.com");
               Console.WriteLine(s1);
              //Thread.Sleep(3000);     //阻塞线程
               await Task.Delay(3000);
              string s2 = await httpClient.GetStringAsync("http://www.baidu.com");
              Console.WriteLine(s2);
    ```

*   CancellationToken 有时需要提前终止任务，比如：请求超时、用户取消请求 很多异步方法都有CancellationToken参数，用于获取提前终止执行的信号。 CancellationToken结构体 None:空 bool IsCancelaationRequested是否取消 Register(Action callback)注册取消监听 ThrowIfCancellationRequested()如果任务被取消，执行到这句话就抛出异常。

    CancellationTokenSource CancelAfter()超时后发出取消信号 Cancel（）发出取消信号 CancellationToken Token

    ```javascript
            static async Task DownloadAsync3(string url,int n ,CancellationToken cancellationToken)  {
             HttpClient httpClient = new HttpClient();
              for (int i =0;i<n;i++){
                     var resp =await httpClient.GetAsync(url,cancellationToken);
                     string html=await resp.Content.ReadAsStringAsync();
                     Console.WriteLine($"{DateTime.Now}:{html}");
              }

          static async Task Main(string[] args) {
              CancellationTokenSource cts = new CancellationTokenSource();
              cts.CancelAfter(4000);
              CancellationToken token = cts.Token;
              await DownloadAsync3("http://www.baidu.com", 200, token);
          }
    ```

*   WhenAll Task\<TResult\[]>tasks)等，所有Task完成，Task才完成。用于等待多个任务执行结束，但是不在乎它们的执行顺序。

    ```
      Task<string> t1 = File.ReadAllTextAsync("d:/1.txt");
          Task<string> t2 = File.ReadAllTextAsync("d:/2.txt");
          Task<string> t3 = File.ReadAllTextAsync("d:/3.txt");
          string[] results = await Task.WhenAll(t1,t2,t3);
          string s1 = results[0];
          string s2 = results[1];
          string s3 = results[2];
          
    ```

*   接口中的异步方法： async是提示编译器为一步方法中的await代码进行分段处理，而一个异步方法是否修饰了async对于方法的调用者来讲没区别，因此对于接口中的方法或抽象方法不能修饰为async。

    `interface  Itest { Task GetCharCount (string file); } class Test : Itest{ public async Task GetCharCount(string file){ string s =await FIle.ReadAllTextAsync(file); return s.length; }`

    ***

    ` }`

