# 面向对象
当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。
### 举例子
问题： 洗衣机里面放有脏衣服，怎么洗干净？
面向对象的解决方法：

1、我先弄出两个对象：“洗衣机”对象和“人”对象

2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法”

3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”

4、然后执行

人.加洗衣粉

人.加水

洗衣机.洗衣服

洗衣机.清洗

洗衣机.烘干

####   面向对象有三大特性：封装，继承，多态。
##### 封装
 指的是将相关数据和行为封装在一个单元（类）中，并通过定义公共接口来控制对数据的访问。
- 数据隐藏：封装通过将数据隐藏在类的内部，防止外部直接访问和修改数据。只有类内部的方法（成员函数）可以操作数据，外部无法绕过类的接口直接访问数据，从而保证了数据的安全性和一致性。

- 公共接口：封装通过定义公共接口（公共方法）来控制对数据的访问。公共接口决定了外部代码可以使用哪些方法来操作对象的数据。通过将数据的操作封装在类的方法中，可以隐藏实现细节，使得对象的使用者只需要关注如何使用接口，而不需要了解内部实现的细节。

- 数据封装和行为组合：封装不仅仅是将数据封装在类中，还包括将与数据相关的行为（方法）封装在一起。这样，数据和行为可以作为一个整体进行组合，并通过类的实例来操作和使用。
```
// 定义一个Person类
public class Person
{
    private string name;
    private int age;

    // 公共属性，用于访问name字段
    public string Name
    {
        get { return name; }
        set { name = value; }
    }

    // 公共属性，用于访问age字段
    public int Age
    {
        get { return age; }
        set { age = value; }
    }

    // 公共方法，用于输出Person对象的信息
    public void DisplayInfo()
    {
        Console.WriteLine("Name: " + name);
        Console.WriteLine("Age: " + age);
    }
}

// 在应用程序中使用封装
public class Program
{
    public static void Main()
    {
        Person person = new Person();

        // 设置对象的属性值
        person.Name = "John";
        person.Age = 25;

        // 输出对象的信息
        person.DisplayInfo();
    }
}
```


##### 继承
它允许一个类（称为子类或派生类）继承另一个类（称为父类、基类或超类）的属性和方法。通过继承，子类可以继承父类的特性，并可以添加、修改或覆盖它们。这样可以实现代码的重用、层次结构的建立和多态性的实现。
继承有以下几个主要概念：

- 父类和子类：父类是被继承的类，子类是继承父类的类。父类中定义的属性和方法可以被子类继承和使用。

- 继承关系：继承关系是一种"is-a"的关系，子类被视为是父类的一种特殊类型。子类可以拥有父类的所有属性和方法，还可以添加自己特有的属性和方法。

- 继承的特性：通过继承，子类可以继承父类的公共和受保护的属性和方法。公共属性和方法可以被任何类访问，受保护的属性和方法可以被子类访问，但对其他类是不可见的。

- 方法覆盖（Override）：子类可以重写（覆盖）继承自父类的方法，以适应自身的需求。在调用该方法时，将使用子类中的实现而不是父类中的实现。

```
// 定义基类
public class Shape
{
    protected int width;
    protected int height;

    public void SetWidth(int w)
    {
        width = w;
    }

    public void SetHeight(int h)
    {
        height = h;
    }
}

// 定义派生类
public class Rectangle : Shape
{
    public int GetArea()
    {
        return width * height;
    }
}

public class Triangle : Shape
{
    public int GetArea()
    {
        return (width * height) / 2;
    }
}

// 在应用程序中使用继承
public class Program
{
    public static void Main()
    {
        Rectangle rect = new Rectangle();
        rect.SetWidth(5);
        rect.SetHeight(10);
        int rectArea = rect.GetArea();
        Console.WriteLine("Rectangle Area: " + rectArea);

        Triangle triangle = new Triangle();
        triangle.SetWidth(4);
        triangle.SetHeight(7);
        int triangleArea = triangle.GetArea();
        Console.WriteLine("Triangle Area: " + triangleArea);
    }
}
```

#### 多态
指的是同一种操作或方法可以在不同的对象上产生不同的行为结果。多态性允许以相同的方式使用不同类型的对象，根据对象的实际类型来执行不同的操作。它通过继承和方法重写实现，是面向对象编程中实现灵活性和可扩展性的关键机制之一。


##### 多态性的主要特点包括：

- 继承关系：多态性建立在类之间的继承关系上。子类继承父类的方法，并可以根据需要进行重写。

- 方法重写（Override）：子类可以重写继承自父类的方法，以适应自身的需求。在调用该方法时，将使用子类中的实现而不是父类中的实现。

- 动态绑定（Dynamic Binding）：多态性通过动态绑定实现。在运行时，根据实际对象的类型来决定使用哪个方法的实现。

```
// 定义基类
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("The animal makes a sound");
    }
}

// 定义派生类
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("The dog barks");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("The cat meows");
    }
}

// 在应用程序中使用多态
public class Program
{
    public static void Main()
    {
        Animal animal1 = new Dog(); // 使用基类引用指向派生类对象
        Animal animal2 = new Cat(); // 使用基类引用指向派生类对象

        animal1.MakeSound(); // 调用派生类重写的方法
        animal2.MakeSound(); // 调用派生类重写的方法
    }
}
```
